<?php
/**
 * This file is part of the {@link http://ontowiki.net OntoWiki} project.
 *
 * @copyright Copyright (c) 2011, {@link http://aksw.org AKSW}
 * @license http://opensource.org/licenses/gpl-license.php GNU General Public License (GPL)
 * @package Extensions
 */

/**
 * The superclass-file providing the chart class skeleton for this class file
 */
require_once 'Chart.php';

/**
 * ScatterPlot chart model class for the ChartView component. This class adapts the
 * parameters of the default chart model to the scatter plot chart. Moreover, a
 * special procedure for creating the internal data model out of two elements on 
 * the xAxis is implemented.
 *
 * @copyright Copyright (c) 2011, {@link http://aksw.org AKSW}
 * @license http://opensource.org/licenses/gpl-license.php GNU General Public License (GPL)
 * @category OntoWiki
 * @package Extensions
 * @subpackage Cubeviz
 * @author Tom-Michael Hesse <tommichael.hesse@googlemail.com>
 */
class ScatterPlotChart extends Chart {
    
    /**
     * Holds the type of the chart represented as a name string
     * @var string The type of the chart as string
     * @see Chart::$_type 
     */
    protected static $_type = 'scatterplot';
    
    /**
     * Holds the limits as numbers of dimensions and measures of the chart for 
     * which the chart model can be applied
     * @var array The limits of the chart: 'minDimension' => int, 
     * 'maxDimension' => int, 'minMeasure' => int, 'maxMeasure' => int
     * @see Chart::$_limits
     */
    protected static $_limits = array('minDimension' => 1, 'maxDimension' => 99,
        'minMeasure' => 1, 'maxMeasure' => 1);
    
    /**
     * Initializes the chart model with all needed data for generating the series
     * and meta information.
     * @param array $dimensionData The dimension data to be used in the chart;
     * generated by the cube helper
     * @param array $measureData The measure data to be used in the chart;
     * generated by the cube helper
     * @param array $nameTable The name table for the qualified names of the
     * dimensions and measures; generated by the cube helper
     * @param array $dimensions The dimensions with their axis allocation to be used
     * in the chart
     * @param array $measures The measures to be used in the chart
     * @param array $titles The titles array
     * @param Erfurt_Rdf_Model $model The model from which the labels can be aquired
     * @see Chart::__construct()
     */
    public function __construct($dimensionData, $measureData, $nameTable, 
            $dimensions, $measures, $titles, $model) {

        //This is a special implementation of data structuring for scatter plots.
        $tempXYLabels = array();
        $tempZLabels = array();
        $tempData = array();
        $titleHelper;

        //generic test for the appropriate numbers of dimensions and measures
        if(count($nameTable['d']) >= static::$_limits['minDimension'] && 
                count($nameTable['d']) <= static::$_limits['maxDimension'] 
                && count($nameTable['m']) == static::$_limits['maxMeasure']) {

            //initialize the helpers and title variable
            $twoDimensions = (count($nameTable['d']) > 1 ? true : false);
            $xDimension = '';
            $yDimension = '';

            $xDimension = array_search('x', $dimensions);
            $dimQNameX = $nameTable['d'][$xDimension]['qname'];

            //check whether the scatter plot model is applicable, this is only
            //possible if there are 2 elements in the x-Dimension
            $checkX = array();
            foreach($dimensionData as $index => $dimensionTuple) {
                $checkX[$dimensionTuple[$dimQNameX]] = true; 
            }
            
            if(count($checkX) != 2) {
                $this->_message = 'info scatterplot two elements in x needed';
                return;
            }

            if(isset($model)) $titleHelper = new OntoWiki_Model_TitleHelper($model);

            $this->_titles = $titles;
            $titleHelper->addResource($this->_titles['title']);

            //set the x axis
            $this->_xAxis = array('dimensionName' => $nameTable['d'][$xDimension]['label'], 
                'dimensionValues' => array());

            $yDimension = array_search('x', $dimensions);
            $this->_yAxis = array('dimensionName' => $nameTable['d'][$yDimension]['label'], 
                'dimensionValues' => array());

            $this->_zAxis = array('dimensionName' => 'mixed', 'dimensionValues' => array());

            $dimQNameZ = array();
            $measQName = $nameTable['m'][$measures[0]]['qname'];

            $zDimensions = array_keys($dimensions, 'z');
            foreach($zDimensions as $zDimension) {
                $dimQNameZ[$zDimension] = $nameTable['d'][$zDimension]['qname'];
            }

            $axisIndex = array();

            //iterate the data and rearrange the data structure in a way which 
            //is easier to handle
            //first loop: get all elements into the title helper and the measure
            //values into the data array
            foreach ($dimensionData as $index=>$dimensionTuple) {

                if(isset($axisIndex['x'])) {
                    if($dimensionTuple[$dimQNameX] != $axisIndex['x']) {
                        $axisIndex['y'] = $dimensionTuple[$dimQNameX];
                    }
                }
                else {
                    $axisIndex['x'] = $dimensionTuple[$dimQNameX];
                }
                $titleHelper->addResource($dimensionTuple[$dimQNameX]);
                $elementIndex = 'e<>';
                foreach($dimQNameZ as $dimZUri => $dimZName) {
                    $elementIndex .= $dimensionTuple[$dimZName].'<>';
                    $titleHelper->addResource($dimensionTuple[$dimZName]);
                }
                $elementIndex = substr($elementIndex, 0, strlen($elementIndex)-2);
                $tempData[$dimensionTuple[$dimQNameX]][$elementIndex] 
                    = $measureData[$index][$measQName];          
            }              

            //second loop: create the name data for the axis elements
            foreach ($dimensionData as $index=>$dimensionTuple) {

                $axisIndexTemp = $dimensionTuple[$dimQNameX];
                $elementIndex = 'e<>';
                $elementLabel = '';
                foreach($dimQNameZ as $dimZUri => $dimZName) {
                    $elementIndex .= $dimensionTuple[$dimZName].'<>';
                    $elementLabel 
                        .= addslashes($titleHelper->getTitle($dimensionTuple[$dimZName])).', ';
                }
                $elementIndex = substr($elementIndex, 0, strlen($elementIndex)-2);
                $tempXYLabels[$axisIndexTemp] 
                    = addslashes($titleHelper->getTitle($axisIndexTemp));
                $tempZLabels[$elementIndex] = substr($elementLabel, 0, 
                        strlen($elementLabel)-2);          
            }   

            //set the data
            $this->_data = $tempData;

            //set the corresponding axis labels and titles
            $this->_xAxis['dimensionValues'] = $tempXYLabels[$axisIndex['x']];
            $this->_yAxis['dimensionValues'] = $tempXYLabels[$axisIndex['y']];
            $this->_zAxis['dimensionValues'] = $tempZLabels;
            $this->_titles['title']
                    = addslashes($titleHelper->getTitle($this->_titles['title']));
            $this->_titles['subtitle'] = addslashes($this->_titles['subtitle']);
        }
    }
}

?>
